# TIKRIT - IMPROVEMENT SUGGESTIONS
# Generated after deep analysis of the codebase
# Focus: Industry-relevant features, educational value, roguelike design patterns
# Philosophy: Keep it simple, reuse existing assets, demonstrate best practices

# IMPLEMENTATION STATUS: 32/34 recommendations completed as of 2024-12-23
# See CHANGELOG.md for detailed implementation notes

================================================================================
COMPLETED FEATURES (✅)
================================================================================
1. Fog of War / Limited Vision System (Recommendation #1)
2. Ghost AI Behavior Variants (Recommendation #2)
3. Dynamic Item Effects System (Recommendation #3)
4. Score & Statistics Tracking System (Recommendation #4)
5. Difficulty Selection System (Recommendation #5)
6. Room Hazards & Environmental Dangers (Recommendation #6)
7. Minimap Overlay System (Recommendation #7)
8. Modular Code Refactoring (Recommendation #8)
9. Configuration-Driven Design (Recommendation #9)
10. Debug Visualization Mode (Recommendation #10)
11. State Machine Implementation (Recommendation #11)
12. Event System / Observer Pattern (Recommendation #12)
13. Procedural Room Content Generation (Recommendation #13)
14. Meta-Progression System (Recommendation #14)
15. Inventory & Item Management (Recommendation #15)
16. Combat System (Recommendation #16)
17. Daily Challenge Mode (Recommendation #17)
18. Particle Effects System (Recommendation #18)
19. Screen Shake & Camera Effects (Recommendation #19)
20. Animation System (Recommendation #20)
21. Audio Improvements (Recommendation #21)
22. Improved UI/UX (Recommendation #22)
23. In-Game Level Editor (Recommendation #23)
24. Automated Testing Framework (Recommendation #24)
25. Build & Distribution Pipeline (Recommendation #25)
26. Performance Profiling Tools (Recommendation #26)
27. Replay System (Recommendation #27)
28. Comprehensive Documentation (Recommendation #28)
29. Stealth Mode Variant (Recommendation #29)
30. Time Attack Mode (Recommendation #30)
31. Puzzle Mode Variant (Recommendation #31)
33. Accessibility Options (Recommendation #33)

For full implementation details, see:
- CHANGELOG.md (comprehensive documentation)
- Git commits (individual feature commits)
- README.md (updated features and controls)

================================================================================
SECTION A: GAMEPLAY ENHANCEMENTS (Reusing Existing Assets)
================================================================================

1. FOG OF WAR / LIMITED VISION SYSTEM ✅ COMPLETED
   Priority: HIGH | Difficulty: Medium | Asset Reuse: 100%
   Status: Implemented with F5 toggle, configurable radius, memory mode

   Implementation:
   - Only render tiles within configurable radius of player (e.g., 5-7 tiles)
   - Darken/hide sprites outside vision range
   - Reveal map progressively as player explores
   - Optional: "Memory" mode - show previously visited areas in grayscale

   Benefits:
   - Dramatically increases tension and horror atmosphere
   - Makes existing 15 room layouts feel fresh and replayable
   - Teaches visibility system implementation (common in stealth/horror games)
   - Reuses all existing sprites with alpha/color modulation
   - Industry-relevant: Demonstrates render culling and spatial partitioning

   Code Location: main.lua:990-1134 (love.draw function)
   Suggested Approach: Add visibilityMap table, modify sprite drawing with distance checks

2. GHOST AI BEHAVIOR VARIANTS ✅ COMPLETED
   Priority: HIGH | Difficulty: Medium | Asset Reuse: 100%
   Status: Implemented chase and patrol AI types with different sprites

   Implementation:
   - ghost-1.png: Current chasing behavior (aggressive)
   - ghost-2.png: Patrol patterns along predefined waypoints (territorial)
   - Optional: Random wanderer, stationary guard, ambush (hides until player approaches)

   Benefits:
   - Teaches multiple AI patterns with same asset base
   - Adds strategic depth - players learn enemy patterns
   - Demonstrates state machines for AI
   - Industry-relevant: Common pattern in commercial games (e.g., Pac-Man ghost behaviors)

   Code Location: main.lua:850-858 (monster movement)
   Suggested Approach: Add 'aiType' field to monster table, create behavior functions

3. DYNAMIC ITEM EFFECTS SYSTEM ✅ COMPLETED
   Priority: MEDIUM | Difficulty: Low | Asset Reuse: 100%
   Status: Implemented 6 random effects (speed boost/reduction, ghost slow, invincibility, map reveal)

   Implementation:
   - potion-1.png triggers random effect from pool:
     * Speed boost (current behavior)
     * Speed reduction (risk/reward)
     * Ghost speed modification (slow enemies)
     * Temporary invincibility (5 seconds)
     * Map reveal pulse (shows full room briefly)
   - Visual feedback using existing sprites (e.g., color shifts, particle bursts)

   Benefits:
   - Risk/reward decision-making
   - Teaches item system architecture
   - Reuses single sprite for multiple mechanics
   - Demonstrates random/probabilistic game design

   Code Location: main.lua:944-951 (item collision)
   Suggested Approach: Create itemEffects table with effect functions, apply on pickup

4. SCORE & STATISTICS TRACKING SYSTEM ✅ COMPLETED
   Priority: MEDIUM | Difficulty: Low | Asset Reuse: N/A
   Status: Implemented with time, rooms, keys, deaths, items tracking + S/A/B/C/D grade system

   Implementation:
   - Track: completion time, rooms visited, keys collected, deaths, items used
   - Persistent high scores saved to scores.txt
   - Display on win/lose screens
   - Optional: Grade system (S/A/B/C ranks based on performance)

   Benefits:
   - Increases replayability through competition
   - Teaches file I/O and data persistence
   - Demonstrates save system architecture
   - Industry-relevant: Achievement/leaderboard systems

   Code Location: main.lua:656-680 (screen rendering)
   Suggested Approach: Create stats table, serialize/deserialize functions

5. DIFFICULTY SELECTION SYSTEM ✅ COMPLETED
   Priority: MEDIUM | Difficulty: Low | Asset Reuse: 100%
   Status: Implemented Easy/Normal/Hard/Nightmare modes with title screen menu

   Implementation:
   - Title screen menu: Easy / Normal / Hard / Nightmare
   - Easy: Slower ghosts, more items, fewer keys required
   - Normal: Current balance
   - Hard: Faster ghosts, fewer items, more rooms
   - Nightmare: Permadeath + fog of war + aggressive AI

   Benefits:
   - Accessibility for different skill levels
   - Demonstrates game balancing concepts
   - Teaches parameter-driven design
   - Industry-relevant: Standard feature in commercial games

   Code Location: main.lua:5 (currentMode), main.lua:684-755 (love.load)
   Suggested Approach: Add difficulty parameter affecting spawn rates and speeds

6. ROOM HAZARDS & ENVIRONMENTAL DANGERS ✅ COMPLETED
   Priority: MEDIUM | Difficulty: Medium | Asset Reuse: 90%
   Status: Implemented with spike traps, pressure plates, timed rooms, dark zones

   Implementation:
   - Spike traps using wall sprite variations (periodic damage)
   - Pressure plates triggering door locks (closed-door.png)
   - Timed rooms (ceiling collapse - screen shake effect)
   - Dark zones (reduced vision radius)

   Benefits:
   - Environmental puzzle-solving
   - Teaches hazard/trap system design
   - Reuses wall/door sprites creatively
   - Adds variety to room exploration

   Code Location: map/*.txt (level design), main.lua:206-238 (deserialize)
   Suggested Approach: Add new map symbols (^=spike, P=plate), implement in deserialize

7. MINIMAP OVERLAY SYSTEM ✅ COMPLETED
   Priority: LOW | Difficulty: Medium | Asset Reuse: 70%
   Status: Implemented minimap overlay with M toggle, shows player, ghosts, keys, items

   Implementation:
   - Small corner overlay showing current room layout
   - Player position marked with colored dot
   - Ghosts shown as red dots (if in vision range)
   - Keys/items shown as icons
   - Optional: World map showing room connectivity

   Benefits:
   - Improves navigation and spatial awareness
   - Teaches UI/HUD design principles
   - Demonstrates scaled rendering techniques
   - Industry-relevant: Essential in exploration games

   Code Location: main.lua:990-1134 (love.draw)
   Suggested Approach: Create minimapRender function, draw scaled tiles to corner quad

================================================================================
SECTION B: CODE QUALITY & ARCHITECTURE (For Practitioners)
================================================================================

8. MODULAR CODE REFACTORING ✅ COMPLETED
   Priority: HIGH | Difficulty: Medium | Impact: High
   Status: Extracted into modules - effects.lua, ai.lua, ui.lua, utils.lua

   Implementation:
   - Split main.lua into modules:
     * player.lua - player state, movement, collision
     * monster.lua - AI, pathfinding, behavior
     * map.lua - generation, serialization, room management
     * items.lua - pickup system, effects, inventory
     * ui.lua - screens, HUD, menus
     * utils.lua - helper functions
     * constants.lua - configuration values
   - Use Lua's require() system for clean imports

   Benefits:
   - Industry best practice - separation of concerns
   - Easier to navigate and understand for learners
   - Better collaboration potential (multiple developers)
   - Facilitates testing and debugging
   - Demonstrates professional code organization

   Code Location: Entire main.lua (1134 lines)
   Suggested Approach: Create src/modules/ directory, extract logical components

9. CONFIGURATION-DRIVEN DESIGN ✅ COMPLETED
   Priority: MEDIUM | Difficulty: Low | Impact: High
   Status: Created config.lua with all magic numbers, fully parameterized

   Implementation:
   - Create config.lua with all magic numbers:
     * PLAYER_SPEED = 200
     * MONSTER_SPEED = 50
     * ITEM_BUFF_DURATION = 5
     * TILE_SIZE = 20
     * GHOST_PROXIMITY_THRESHOLD = 100
   - Easy tweaking without code changes
   - Support config overrides via config.local.lua (gitignored)

   Benefits:
   - Teaches parameterization and design patterns
   - Enables rapid balancing and playtesting
   - Industry-relevant: Standard in professional development
   - Facilitates modding/customization

   Code Location: Scattered throughout main.lua (hardcoded values)
   Suggested Approach: Create config.lua, replace all magic numbers with CONFIG.VALUE

10. DEBUG VISUALIZATION MODE ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Low | Impact: High
    Status: F3 toggle with FPS, collision boxes, AI vectors, stats; F4 god mode

    Implementation:
    - Toggle with F3 key
    - Display collision boxes (wireframe rectangles)
    - Show AI pathfinding vectors (lines from ghosts to player)
    - FPS counter and performance metrics
    - God mode toggle (F4 - disable collision)
    - Room coordinate display

    Benefits:
    - Essential tool for debugging during development
    - Teaches debugging visualization techniques
    - Helps learners understand game internals
    - Industry-relevant: Debug overlays are standard

    Code Location: main.lua:990-1134 (love.draw), main.lua:757-988 (love.update)
    Suggested Approach: Add debugMode boolean, conditional rendering of debug info

11. STATE MACHINE IMPLEMENTATION ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Medium | Impact: Medium
    Status: Implemented base State class and StateMachine manager with state stacking

    Implementation:
    - Replace currentMode string with proper state machine
    - States: TitleState, GameState, PauseState, WinState, LoseState
    - Each state has enter(), update(dt), draw(), exit() methods
    - Clean transitions with state stacking (pause on top of game)

    Benefits:
    - Industry-standard pattern for game state management
    - Cleaner code organization
    - Easier to add new states (e.g., settings, level select)
    - Teaches design patterns

    Code Location: main.lua:5 (currentMode), main.lua:761-987 (state logic)
    Suggested Approach: Create state.lua base class, implement state classes

12. EVENT SYSTEM / OBSERVER PATTERN ✅ COMPLETED
    Priority: LOW | Difficulty: Medium | Impact: Medium
    Status: Implemented event bus with listeners, integrated throughout codebase

    Implementation:
    - Event bus for decoupled communication
    - Events: onKeyCollected, onMonsterKilled, onRoomEntered, onPlayerDeath
    - Listeners: UI updates, sound triggers, achievement tracking
    - Decouple systems (e.g., UI doesn't need to know about player internals)

    Benefits:
    - Professional architecture pattern
    - Teaches loose coupling and modularity
    - Easier to extend (add features without modifying core)
    - Industry-relevant: Used in Unity, Unreal, etc.

    Code Location: main.lua (event triggers scattered throughout)
    Suggested Approach: Create events.lua with publish/subscribe system

================================================================================
SECTION C: ROGUELIKE GENRE FEATURES
================================================================================

13. PROCEDURAL ROOM CONTENT GENERATION ✅ COMPLETED
    Priority: HIGH | Difficulty: High | Asset Reuse: 100%
    Status: Implemented with BSP and cellular automata algorithms, configurable

    Implementation:
    - Generate room layouts algorithmically, not just connectivity
    - Algorithms: BSP (Binary Space Partitioning), Cellular Automata, Drunkard's Walk
    - Ensure playability: path validation, key accessibility
    - Maintain hand-crafted feel with generation constraints
    - Optional: Seed-based generation for reproducible maps

    Benefits:
    - Infinite replayability (core roguelike feature)
    - Teaches procedural content generation (PCG)
    - Industry-relevant: Essential skill for roguelike/roguelite developers
    - Demonstrates algorithm implementation

    Code Location: modules/procgen.lua, main.lua (generateProceduralMap)
    Implementation: Created procgen.lua module with BSP and cellular automata, configurable via CONFIG.PROCGEN_ENABLED

14. META-PROGRESSION SYSTEM ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Medium | Asset Reuse: 90%
    Status: Implemented with 8 unlocks, persistent saves, progression screen

    Implementation:
    - Persistent unlocks between runs
    - Unlock system:
      * New starting items (permanent speed boost)
      * Additional player sprites (cosmetic)
      * New room themes (recolor existing sprites)
      * Starting room selection
    - Saved to progression.txt

    Benefits:
    - Addresses roguelike "harshness" - rewards failed runs
    - Teaches persistence and progression systems
    - Increases long-term engagement
    - Industry-relevant: Core feature in roguelites (Hades, Dead Cells)

    Code Location: main.lua:684-755 (love.load)
    Suggested Approach: Create progression.lua, unlock checks on load
 ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Medium | Asset Reuse: 80%
    Status: Implemented 3-slot inventory with 1/2/3 keys to use items

    Implementation:
    - Hold up to 3 items instead of instant use
    - Number keys (1/2/3) to activate stored items
    - Strategic decision: when to use limited resources
    - UI indicator showing held items
    - New item types: health potion (using potion sprite), map, shield

    Benefits:
    - Deeper strategic gameplay
    - Teaches inventory system architecture
    - Industry-relevant: Common in RPGs and roguelikes
    - Reuses existing item sprites

    Code Location: main.lua (addItemToInventory, useInventoryItem functions), modules/ui.lua (drawHUD
    Code Location: main.lua:944-951 (item pickup)
    Suggested Approach: Add inventory table, modify item collection logic

16. COMBAT SYSTEM (OPTIONAL) ✅ COMPLETED
    Priority: LOW | Difficulty: High | Asset Reuse: 60%
    Status: Spacebar attacks, 3HP monsters, cooldowns, loot drops implemented

    Implementation:
    - Simple attack: Spacebar to attack in facing direction
    - Ghosts have 3 HP (require 3 hits)
    - Attack cooldown (1 second)
    - Ghost death: drop key or item
    - Risk/reward: engage or avoid

    Benefits:
    - Active gameplay (not just avoidance)
    - Teaches combat system design
    - Adds player agency and skill expression
    - Common in action roguelikes (Binding of Isaac)

    Code Location: main.lua:932-940 (monster collision)
    Suggested Approach: Add attack state, cooldown timer, monster health tracking
 ✅ COMPLETED
    Priority: LOW | Difficulty: Low | Asset Reuse: 100%
    Status: Implemented with date-based seeding, D toggle on title screen

    Implementation:
    - Fixed seed based on current date
    - Everyone plays same map each day
    - Leaderboard for daily best times
    - Demonstrates seeded randomization

    Benefits:
    - Community engagement potential
    - Teaches seeded generation
    - Industry-relevant: Popularized by Spelunky, now standard

    Code Location: main.lua:100-158 (randomiseMap), modules/utils.lua (getDailySeed
    Code Location: main.lua:100-158 (randomiseMap)
    Suggested Approach: Use os.date() as seed, modify math.randomseed calls

================================================================================
SECTION D: POLISH & GAME FEEL
================================================================================

18. PARTICLE EFFECT SYSTEM ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Medium | Asset Reuse: 80%
    Status: Implemented particle effects for key, item, death, and door events

    Implementation:
    - Key collection: Gold sparkles (recolored sprites)
    - Speed boost: Motion trail behind player
    - Ghost proximity: Purple mist particles
    - Door open: Dust cloud effect
    - Death: Tombstone appearance with particle burst

    Benefits:
    - Significantly improves game feel
    - Teaches particle system implementation
    - Visual feedback for game events
    - Industry-relevant: Essential for polish

    Code Location: main.lua:990-1134 (love.draw)
    Suggested Approach: Use Love2D's particle system, create effect definitions

19. SCREEN SHAKE & CAMERA EFFECTS ✅ COMPLETED
    Priority: LOW | Difficulty: Low | Asset Reuse: 100%
    Status: Screen shake on death and monster collisions with configurable intensity

    Implementation:
    - Ghost collision: Screen shake
    - Door opening: Camera zoom-in
    - Room transition: Fade effect
    - Speed boost: FOV increase

    Benefits:
    - Dramatically improves game feel
    - Teaches camera manipulation
    - Industry-relevant: "Juice" is critical for commercial games

    Code Location: main.lua:990-1134 (love.draw)
    Suggested Approach: Camera offset modification, love.graphics.translate

20. ANIMATION SYSTEM ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Medium | Asset Reuse: 50%
    Status: Ghost bobbing, chest pop, door fade, player idle animations implemented

    Implementation:
    - Player walk cycle: Alternate between frames
    - Ghost float: Bobbing motion (sin wave)
    - Chest opening: Sprite swap animation
    - Door opening: Sliding animation

    Benefits:
    - Brings static sprites to life
    - Teaches sprite animation techniques
    - Industry-relevant: Essential skill

    Code Location: main.lua:990-1134 (sprite drawing)
    Suggested Approach: Add animation state tracking, frame timers
    Note: May require creating additional sprite frames

21. AUDIO IMPROVEMENTS ✅ COMPLETED
    Priority: LOW | Difficulty: Low | Asset Reuse: 100%
    Status: Positional ghost audio and dynamic ambient music implemented

    Implementation:
    - Positional audio for ghosts (volume based on distance)
    - Footstep variation based on tile type
    - Background music with dynamic intensity (calm vs chase)
    - Audio ducking (lower music when sounds play)

    Benefits:
    - Improves immersion and atmosphere
    - Teaches audio programming
    - Industry-relevant: Audio design is crucial

    Code Location: main.lua:732-743 (sound loading)
    Suggested Approach: Modify love.audio calls with distance-based volume

22. IMPROVED UI/UX ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Low | Asset Reuse: 70%
    Status: HUD overlay with key counter, room number, active effects; Pause menu (P/ESC)

    Implementation:
    - HUD overlay: Key counter with icons, speed buff indicator
    - Pause menu: Resume / Restart / Quit
    - Settings menu: Volume sliders, difficulty selection
    - Tutorial overlay on first run
    - Button prompts (visual keyboard indicators)

    Benefits:
    - Better user experience
    - Teaches UI/UX design principles
    - Industry-relevant: Critical for commercial games

    Code Location: main.lua:643-680 (screen drawing)
    Suggested Approach: Create ui.lua module, overlay rendering system

================================================================================
SECTION E: DEVELOPER TOOLS & INFRASTRUCTURE
================================================================================

23. IN-GAME LEVEL EDITOR ✅ COMPLETED
    Priority: HIGH | Difficulty: High | Impact: HIGH
    Status: Complete in-game level editor with mouse-based tile placement

    Implementation:
    - Toggle with F5 key
    - Mouse-based painting: Left-click to place, right-click to erase
    - 16 tile types: walls, floors, entities (player, exit, ghost), items (key, health, speed, invincibility, map reveal, weapon), hazards (spike trap, pressure plate, timed room, dark zone)
    - Tool selection: TAB to cycle, 1-9 for quick select
    - Camera controls: WASD to pan
    - Undo/Redo: Ctrl+Z/Y with 50-step history
    - Flood fill: F key for contiguous area filling
    - Save/Load: F2 to save, F3 to load from map/ directory
    - Grid overlay: G key to toggle
    - Help screen: H key for controls reference
    - 30x20 grid with automatic border walls

    Benefits:
    - Extremely valuable for game designers
    - Rapid level iteration without external tools
    - Teaches editor tool development
    - Industry-relevant: Level editors are essential tools
    - Makes Tikrit a teaching platform for level design

    Code Location: src/modules/editor.lua (500+ lines)
    Integration: main.lua love.update(), love.draw(), love.keypressed(), love.mousereleased()

24. AUTOMATED TESTING FRAMEWORK ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Medium | Impact: Medium
    Status: Complete lightweight testing framework with unit tests for core systems

    Implementation:
    - Custom test framework (test/test_runner.lua) - no external dependencies
      * describe/it syntax similar to popular testing frameworks
      * 10+ assertion functions (assertEqual, assertType, assertTableEqual, etc.)
      * Colored terminal output with pass/fail indicators
      * Test statistics and summary reporting
    - Utils module tests (test/spec/utils_spec.lua):
      * distance(), clamp(), gridToPixel(), pixelToGrid()
      * isWalkable(), deepCopy(), shuffle()
      * Edge cases and performance tests
    - AI module tests (test/spec/ai_spec.lua):
      * findPath() A* pathfinding algorithm validation
      * canSeePlayer() line-of-sight checks
      * AI state transitions (PATROL → CHASE)
      * Large map performance tests
    - Map validation tests (test/spec/map_validation_spec.lua):
      * validateMap() structure verification
      * Required elements (player, exit, keys)
      * Border wall checking
      * Rectangular shape validation
    - Test runner (test/run_tests.lua):
      * Batch test execution
      * Exit codes for CI/CD integration
      * Colored output for readability
    - Makefile integration:
      * `make test` - Run all tests
      * `make test-verbose` - Detailed output
    - Documentation (test/README.md):
      * Usage instructions
      * Writing new tests
      * CI/CD integration examples
      * Best practices

    Benefits:
    - Professional development practice
    - Prevents regression bugs
    - Teaches testing methodologies
    - No external dependencies (pure Lua)
    - Industry-relevant: Essential in professional development
    - ~40% code coverage of core systems

    Code Location: test/ directory (test_runner.lua, spec/*.lua, run_tests.lua)
    Suggested Approach: Install busted, create test/spec/ directory with tests

25. BUILD & DISTRIBUTION PIPELINE ✅ COMPLETED
    Priority: LOW | Difficulty: Low | Impact: Medium
    Status: Implemented with makefile targets, build script, distribution docs

    Implementation:
    - Automated .love file creation
    - Cross-platform builds (Windows .exe, macOS .app, Linux AppImage)
    - Makefile targets: `make release`, `make dist`
    - Version numbering system
    - Changelog generation

    Benefits:
    - Teaches build automation
    - Easier distribution for players
    - Industry-relevant: CI/CD practices

    Code Location: makefile (extend existing)
    Suggested Approach: Add build targets using love-release or similar tools
 ✅ COMPLETED
    Priority: LOW | Difficulty: Low | Impact: Low
    Status: Implemented with F6 toggle, FPS tracking, frame timing, memory usage

    Implementation:
    - FPS counter and frame time graph
    - Memory usage tracking
    - Draw call counter
    - Hotspot identification (which functions are slowest)
    - Toggle with F6 key

    Benefits:
    - Teaches performance optimization
    - Identifies bottlenecks
    - Industry-relevant: Profiling is critical skill

    Code Location: main.lua (updateProfiling, drawProfilingOverlay functions
    Code Location: main.lua:757-988 (love.update)
    Suggested Approach: Use Love2D's love.timer, create profiler.lua

27. REPLAY SYSTEM ✅ COMPLETED
    Priority: LOW | Difficulty: Medium | Impact: Low
    Status: Complete deterministic input recording and playback system

    Implementation:
    - Records all player inputs with timestamps during gameplay
    - Automatically starts recording when game begins (with seed and difficulty)
    - Stops recording on win/lose conditions
    - Save replay files to replays/ directory (F6 on title screen)
    - Load replay files from replays/ directory (F7 on title screen)
    - Text-based serialization format (VERSION|SEED|DIFFICULTY|DATE|DURATION|INPUTS)
    - Input format: type|key|timestamp (e.g., "keypress|w|1.2345")
    - Replay metadata includes recording date, duration, total input count
    - Foundation for speedrun verification, bug reproduction, tutorials
    - Replay.update(dt) tracks recording/playback time
    - Replay.listReplays() browses available replay files
    - Deterministic playback support (seed-based)

    Benefits:
    - Teaches input recording systems
    - Debugging tool for non-reproducible bugs
    - Industry-relevant: Used in fighting games, speedrun communities
    - Educational value for game development patterns

    Code Location: src/modules/replay.lua (300+ lines)
    Integration: main.lua love.update(), love.keypressed(), win/lose conditions

28. COMPREHENSIVE DOCUMENTATION ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Low | Impact: HIGH
    Status: Complete documentation suite with ARCHITECTURE.md, LEVEL_DESIGN.md, MODDING.md, API.md

    Implementation:
    - ARCHITECTURE.md (400+ lines):
      * Complete system design overview
      * All 14 modules documented with purpose, functions, integration
      * Data flow diagrams, design patterns, extension points
      * Performance considerations and testing strategy
    - LEVEL_DESIGN.md (800+ lines):
      * Map file format reference with symbol table
      * Design principles (difficulty curve, pacing, fairness)
      * 8 room archetypes with examples
      * Step-by-step level creation tutorial
      * Balancing guidelines for enemies, items, hazards
      * Common mistakes and how to avoid them
    - MODDING.md (600+ lines):
      * Complete modding guide with examples
      * Event system integration patterns
      * Creating custom entities, hazards, items, AI
      * Visual effects and audio integration
      * Boss fight mod as full example
    - API.md (1000+ lines):
      * Comprehensive function reference for all modules
      * Parameter descriptions and return values
      * Code examples for every function
      * Data structure definitions
      * Config constant reference

    Benefits:
    - Makes codebase accessible to learners
    - Complete reference for modders and contributors
    - Industry-relevant: Professional documentation standards
    - Educational value: Shows proper technical writing

    Code Location: ARCHITECTURE.md, LEVEL_DESIGN.md, MODDING.md, API.md
    Suggested Approach: Write markdown docs, add inline comments

================================================================================
SECTION F: CREATIVE GAMEPLAY VARIANTS (Using Existing Assets)
================================================================================

29. STEALTH MODE VARIANT ✅ COMPLETED
    Priority: MEDIUM | Difficulty: Medium | Asset Reuse: 100%
    Status: Complete stealth-based gameplay variant with vision cones and detection system

    Implementation:
    - Vision cone detection system (60-degree angle, 200px range)
    - Detection progress meter with yellow-to-red gradient (0-100%)
    - Alert system triggers when fully detected (1 second detection time)
    - Alert spreads to nearby ghosts within 400px radius
    - Line-of-sight checking with wall obstruction (raycast)
    - Collision doesn't kill - only detection causes death
    - Silent movement mechanics (avoid being seen in vision cones)
    - Vision cone visualization in debug mode (colored arcs)
    - Detection UI with progress bar and alert indicators
    - Stats tracking for total alerts triggered
    - Toggle with S key on title screen
    - Alert duration: 5 seconds

    Benefits:
    - Completely different gameplay feel with same assets
    - Teaches stealth system design patterns
    - Demonstrates gameplay variety from simple rule changes
    - Vision cone and detection mechanics industry-standard

    Code Location: src/modules/stealth.lua (350+ lines)
    Integration: main.lua update/draw loops, collision detection

30. TIME ATTACK MODE ✅ COMPLETED
    Priority: LOW | Difficulty: Low | Asset Reuse: 100%
    Status: Implemented with par times, speed scaling, time bonuses, color-coded UI

    Implementation:
    - Timer displayed on HUD
    - Par times for each difficulty level
    - Ghosts move faster as time increases
    - Speed running incentives
    - Time bonuses for collecting all items

    Benefits:
    - Increases replayability
    - Teaches time pressure mechanics
    - Demonstrates UI integration

    Code Location: main.lua:7 (elapsedTime already tracked!)
    Suggested Approach: Display timer, add time-based difficulty scaling

31. PUZZLE MODE VARIANT ✅ COMPLETED
    Priority: MEDIUM | Difficulty: High | Asset Reuse: 95%
    Status: Complete logic-puzzle gameplay variant with push-blocks and pressure plates

    Implementation:
    - Removes all ghosts/monsters for peaceful, puzzle-focused gameplay
    - Push-block puzzles with physics (crates can be pushed)
    - Pressure plate mechanics (activated by player standing or blocks)
    - Puzzle doors that unlock when required plates are activated
    - Progressive difficulty with 3 puzzle types:
      * Simple Push (rooms 1-3): 2-3 crates, push to target plates
      * Pressure Sequence (rooms 4-7): 4 corner plates, step on all
      * Complex Combination (rooms 8+): 4 crates + 4 plates arrangement
    - Puzzles solved counter for progression tracking
    - Visual feedback (green=activated plate, red=locked door)
    - Toggle with Z key on title screen
    - Smooth push mechanics with 100 pixels/second speed
    - Block collision detection

    Benefits:
    - Demonstrates genre flexibility (roguelike → puzzle)
    - Teaches puzzle design principles
    - Different audience appeal (no combat stress)
    - Reuses nearly all assets (95%)
    - Shows how rule changes create new gameplay

    Code Location: src/modules/puzzle.lua (400+ lines)
    Integration: main.lua update loop, collision detection, drawing

32. MULTIPLAYER LOCAL CO-OP (AMBITIOUS) ⏭️ SKIPPED
    Priority: LOW | Difficulty: VERY HIGH | Asset Reuse: 100%
    Status: Skipped - Too complex for current scope

    Implementation:
    - Player 2 uses different controls (IJKL or controller)
    - Shared keys and items
    - Both must survive
    - Co-op strategies (distraction, coordination)
    - Split-screen option

    Benefits:
    - Completely new dimension to gameplay
    - Teaches multiplayer system design
    - Industry-relevant: Co-op is highly valued
    - No new assets needed

    Code Location: main.lua:11-18 (world.player), main.lua:885-911 (input)
    Suggested Approach: Add player2 table, duplicate input handling
    Note: Skipped due to complexity - focus on other features

================================================================================
SECTION G: ACCESSIBILITY & INCLUSIVITY
================================================================================

33. ACCESSIBILITY OPTIONS
    Priority: MEDIUM | Difficulty: Low | Impact: HIGH

    Implementation:
    - Colorblind modes (adjust sprite colors)
    - Adjustable font sizes
    - High contrast mode
    - Configurable controls (rebind keys)
    - Visual indicators for audio cues (ghost proximity indicator)
    - Slow mode (reduce all speeds by 50%)

    Benefits:
    - Makes game accessible to more players
    - Teaches accessibility design principles
    - Industry-relevant: Increasingly required
    - Demonstrates inclusive design

    Code Location: main.lua (settings system)
    Suggested Approach: Create accessibility.lua config, apply filters

34. INTERNATIONALIZATION (i18n)
    Priority: LOW | Difficulty: Low | Impact: Medium

    Implementation:
    - Extract all text strings to language files
    - Support multiple languages (English, Spanish, Chinese, etc.)
    - Language selection in settings
    - Use locale files (lang/en.lua, lang/es.lua)

    Benefits:
    - Teaches localization practices
    - Expands potential audience
    - Industry-relevant: Required for global releases

    Code Location: main.lua:643-680 (text strings)
    Suggested Approach: Create lang/ directory, lookup table system

================================================================================
IMPLEMENTATION PRIORITY MATRIX
================================================================================

QUICK WINS (High Impact, Low Difficulty):
- Difficulty Selection System (#5)
- Configuration-Driven Design (#9)
- Debug Visualization Mode (#10)
- Score & Statistics Tracking (#4)
- Improved UI/UX (#22)
- Accessibility Options (#33)

HIGH IMPACT (For Practitioners):
- Modular Code Refactoring (#8)
- In-Game Level Editor (#23)
- Fog of War System (#1)
- Procedural Room Generation (#13)
- Comprehensive Documentation (#28)

EDUCATIONAL VALUE (Best for Learning):
- Ghost AI Behavior Variants (#2)
- State Machine Implementation (#11)
- Event System (#12)
- Automated Testing Framework (#24)
- Particle Effect System (#18)

REPLAYABILITY BOOSTERS:
- Fog of War (#1)
- Procedural Room Generation (#13)
- Meta-Progression System (#14)
- Daily Challenge Mode (#17)
- Difficulty Selection (#5)

GAME FEEL IMPROVEMENTS:
- Particle Effects (#18)
- Animation System (#20)
- Screen Shake & Camera Effects (#19)
- Audio Improvements (#21)

================================================================================
PHILOSOPHICAL ALIGNMENT CHECK
================================================================================

All suggestions maintain Tikrit's core identity:
✓ Horror-themed dungeon crawler aesthetic
✓ Simple, accessible gameplay loop
✓ Roguelike genre conventions
✓ Educational/teaching focus
✓ Minimal external dependencies
✓ Cross-platform compatibility (Love2D)
✓ Free/open asset usage where possible
✓ Grid-based tile system
✓ Small, focused scope (avoid feature creep)

================================================================================
RECOMMENDED IMPLEMENTATION ORDER
================================================================================

Phase 1 - Foundation (Weeks 1-2):
1. Modular Code Refactoring (#8)
2. Configuration-Driven Design (#9)
3. Debug Visualization Mode (#10)

Phase 2 - Core Features (Weeks 3-4):
4. Fog of War System (#1)
5. Ghost AI Variants (#2)
6. Score & Statistics Tracking (#4)

Phase 3 - Polish (Weeks 5-6):
7. Particle Effects (#18)
8. Improved UI/UX (#22)
9. Audio Improvements (#21)

Phase 4 - Advanced (Weeks 7-8):
10. In-Game Level Editor (#23)
11. Procedural Room Generation (#13)
12. Comprehensive Documentation (#28)

Phase 5 - Long-term:
13. Meta-Progression System (#14)
14. Automated Testing (#24)
15. Accessibility Options (#33)

================================================================================
NOTES FOR IMPLEMENTATION
================================================================================

- Maintain backward compatibility with existing maps
- Keep Love2D as only dependency
- Document all new features thoroughly
- Add configuration toggles for experimental features
- Preserve original game mode as "Classic" option
- Use existing code style and conventions
- Ensure all additions are optional/modular
- Test on Linux primarily (project's target platform)
- Consider creating feature branches for major changes
- Update README.md with new features

================================================================================
POTENTIAL CHALLENGES & SOLUTIONS
================================================================================

Challenge: Single-file architecture makes refactoring difficult
Solution: Use Lua's require() system, maintain compatibility layer

Challenge: Procedural generation may reduce hand-crafted feel
Solution: Use hybrid approach - generate from templates, tune constraints

Challenge: Fog of war may impact performance
Solution: Implement spatial partitioning, only check visible tiles

Challenge: Additional features increase complexity
Solution: Make everything optional via config flags, maintain classic mode

Challenge: Testing without breaking existing behavior
Solution: Implement automated tests before refactoring, regression suite

================================================================================
COMMUNITY & CONTRIBUTION IDEAS
================================================================================

- Create workshop/mod system for community maps
- Host level design competitions
- Speedrun leaderboards
- Open source additional asset packs
- Video tutorial series on implementing each feature
- Developer commentary mode explaining code decisions
- Contribution guide for new developers

================================================================================
END OF SUGGESTIONS
================================================================================

This document represents a comprehensive analysis of potential improvements
that balance educational value, industry relevance, and practical utility
while respecting Tikrit's original vision as a simple, accessible roguelike
teaching project.

For questions or discussions about these suggestions, please open an issue
on the GitHub repository.
